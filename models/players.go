// Code generated by SQLBoiler 4.16.2 (https://github.com/volatiletech/sqlboiler). DO NOT EDIT.
// This file is meant to be re-generated in place and/or deleted at any time.

package models

import (
	"context"
	"database/sql"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/friendsofgo/errors"
	"github.com/volatiletech/null/v8"
	"github.com/volatiletech/sqlboiler/v4/boil"
	"github.com/volatiletech/sqlboiler/v4/queries"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"github.com/volatiletech/sqlboiler/v4/queries/qmhelper"
	"github.com/volatiletech/strmangle"
)

// Player is an object representing the database table.
type Player struct {
	ID             string      `boil:"id" json:"id" toml:"id" yaml:"id"`
	CreatedAt      time.Time   `boil:"created_at" json:"created_at" toml:"created_at" yaml:"created_at"`
	UpdatedAt      time.Time   `boil:"updated_at" json:"updated_at" toml:"updated_at" yaml:"updated_at"`
	DeletedAt      null.Time   `boil:"deleted_at" json:"deleted_at,omitempty" toml:"deleted_at" yaml:"deleted_at,omitempty"`
	SelectedCardID null.String `boil:"selected_card_id" json:"selected_card_id,omitempty" toml:"selected_card_id" yaml:"selected_card_id,omitempty"`
	Liens          int64       `boil:"liens" json:"liens" toml:"liens" yaml:"liens"`
	Level          int         `boil:"level" json:"level" toml:"level" yaml:"level"`
	XP             int64       `boil:"xp" json:"xp" toml:"xp" yaml:"xp"`
	NextLevelXP    int64       `boil:"next_level_xp" json:"next_level_xp" toml:"next_level_xp" yaml:"next_level_xp"`
	BackpackLevel  int         `boil:"backpack_level" json:"backpack_level" toml:"backpack_level" yaml:"backpack_level"`
	LiensBidded    int64       `boil:"liens_bidded" json:"liens_bidded" toml:"liens_bidded" yaml:"liens_bidded"`
	Username       string      `boil:"username" json:"username" toml:"username" yaml:"username"`
	SlotsReserved  int         `boil:"slots_reserved" json:"slots_reserved" toml:"slots_reserved" yaml:"slots_reserved"`

	R *playerR `boil:"-" json:"-" toml:"-" yaml:"-"`
	L playerL  `boil:"-" json:"-" toml:"-" yaml:"-"`
}

var PlayerColumns = struct {
	ID             string
	CreatedAt      string
	UpdatedAt      string
	DeletedAt      string
	SelectedCardID string
	Liens          string
	Level          string
	XP             string
	NextLevelXP    string
	BackpackLevel  string
	LiensBidded    string
	Username       string
	SlotsReserved  string
}{
	ID:             "id",
	CreatedAt:      "created_at",
	UpdatedAt:      "updated_at",
	DeletedAt:      "deleted_at",
	SelectedCardID: "selected_card_id",
	Liens:          "liens",
	Level:          "level",
	XP:             "xp",
	NextLevelXP:    "next_level_xp",
	BackpackLevel:  "backpack_level",
	LiensBidded:    "liens_bidded",
	Username:       "username",
	SlotsReserved:  "slots_reserved",
}

var PlayerTableColumns = struct {
	ID             string
	CreatedAt      string
	UpdatedAt      string
	DeletedAt      string
	SelectedCardID string
	Liens          string
	Level          string
	XP             string
	NextLevelXP    string
	BackpackLevel  string
	LiensBidded    string
	Username       string
	SlotsReserved  string
}{
	ID:             "players.id",
	CreatedAt:      "players.created_at",
	UpdatedAt:      "players.updated_at",
	DeletedAt:      "players.deleted_at",
	SelectedCardID: "players.selected_card_id",
	Liens:          "players.liens",
	Level:          "players.level",
	XP:             "players.xp",
	NextLevelXP:    "players.next_level_xp",
	BackpackLevel:  "players.backpack_level",
	LiensBidded:    "players.liens_bidded",
	Username:       "players.username",
	SlotsReserved:  "players.slots_reserved",
}

// Generated where

var PlayerWhere = struct {
	ID             whereHelperstring
	CreatedAt      whereHelpertime_Time
	UpdatedAt      whereHelpertime_Time
	DeletedAt      whereHelpernull_Time
	SelectedCardID whereHelpernull_String
	Liens          whereHelperint64
	Level          whereHelperint
	XP             whereHelperint64
	NextLevelXP    whereHelperint64
	BackpackLevel  whereHelperint
	LiensBidded    whereHelperint64
	Username       whereHelperstring
	SlotsReserved  whereHelperint
}{
	ID:             whereHelperstring{field: "\"players\".\"id\""},
	CreatedAt:      whereHelpertime_Time{field: "\"players\".\"created_at\""},
	UpdatedAt:      whereHelpertime_Time{field: "\"players\".\"updated_at\""},
	DeletedAt:      whereHelpernull_Time{field: "\"players\".\"deleted_at\""},
	SelectedCardID: whereHelpernull_String{field: "\"players\".\"selected_card_id\""},
	Liens:          whereHelperint64{field: "\"players\".\"liens\""},
	Level:          whereHelperint{field: "\"players\".\"level\""},
	XP:             whereHelperint64{field: "\"players\".\"xp\""},
	NextLevelXP:    whereHelperint64{field: "\"players\".\"next_level_xp\""},
	BackpackLevel:  whereHelperint{field: "\"players\".\"backpack_level\""},
	LiensBidded:    whereHelperint64{field: "\"players\".\"liens_bidded\""},
	Username:       whereHelperstring{field: "\"players\".\"username\""},
	SlotsReserved:  whereHelperint{field: "\"players\".\"slots_reserved\""},
}

// PlayerRels is where relationship names are stored.
var PlayerRels = struct {
	IDGithubStar        string
	SelectedCard        string
	GithubStar          string
	Auctions            string
	AuctionsBids        string
	AuthCookies         string
	AuthDiscordStates   string
	AuthGithubStates    string
	Cards               string
	Listings            string
	LootBoxes           string
	PlayerCardFavorites string
	PlayerCards         string
	PlayerCardsDecks    string
}{
	IDGithubStar:        "IDGithubStar",
	SelectedCard:        "SelectedCard",
	GithubStar:          "GithubStar",
	Auctions:            "Auctions",
	AuctionsBids:        "AuctionsBids",
	AuthCookies:         "AuthCookies",
	AuthDiscordStates:   "AuthDiscordStates",
	AuthGithubStates:    "AuthGithubStates",
	Cards:               "Cards",
	Listings:            "Listings",
	LootBoxes:           "LootBoxes",
	PlayerCardFavorites: "PlayerCardFavorites",
	PlayerCards:         "PlayerCards",
	PlayerCardsDecks:    "PlayerCardsDecks",
}

// playerR is where relationships are stored.
type playerR struct {
	IDGithubStar        *GithubStar             `boil:"IDGithubStar" json:"IDGithubStar" toml:"IDGithubStar" yaml:"IDGithubStar"`
	SelectedCard        *Card                   `boil:"SelectedCard" json:"SelectedCard" toml:"SelectedCard" yaml:"SelectedCard"`
	GithubStar          *GithubStar             `boil:"GithubStar" json:"GithubStar" toml:"GithubStar" yaml:"GithubStar"`
	Auctions            AuctionSlice            `boil:"Auctions" json:"Auctions" toml:"Auctions" yaml:"Auctions"`
	AuctionsBids        AuctionsBidSlice        `boil:"AuctionsBids" json:"AuctionsBids" toml:"AuctionsBids" yaml:"AuctionsBids"`
	AuthCookies         AuthCookieSlice         `boil:"AuthCookies" json:"AuthCookies" toml:"AuthCookies" yaml:"AuthCookies"`
	AuthDiscordStates   AuthDiscordStateSlice   `boil:"AuthDiscordStates" json:"AuthDiscordStates" toml:"AuthDiscordStates" yaml:"AuthDiscordStates"`
	AuthGithubStates    AuthGithubStateSlice    `boil:"AuthGithubStates" json:"AuthGithubStates" toml:"AuthGithubStates" yaml:"AuthGithubStates"`
	Cards               CardSlice               `boil:"Cards" json:"Cards" toml:"Cards" yaml:"Cards"`
	Listings            ListingSlice            `boil:"Listings" json:"Listings" toml:"Listings" yaml:"Listings"`
	LootBoxes           LootBoxSlice            `boil:"LootBoxes" json:"LootBoxes" toml:"LootBoxes" yaml:"LootBoxes"`
	PlayerCardFavorites PlayerCardFavoriteSlice `boil:"PlayerCardFavorites" json:"PlayerCardFavorites" toml:"PlayerCardFavorites" yaml:"PlayerCardFavorites"`
	PlayerCards         PlayerCardSlice         `boil:"PlayerCards" json:"PlayerCards" toml:"PlayerCards" yaml:"PlayerCards"`
	PlayerCardsDecks    PlayerCardsDeckSlice    `boil:"PlayerCardsDecks" json:"PlayerCardsDecks" toml:"PlayerCardsDecks" yaml:"PlayerCardsDecks"`
}

// NewStruct creates a new relationship struct
func (*playerR) NewStruct() *playerR {
	return &playerR{}
}

func (r *playerR) GetIDGithubStar() *GithubStar {
	if r == nil {
		return nil
	}
	return r.IDGithubStar
}

func (r *playerR) GetSelectedCard() *Card {
	if r == nil {
		return nil
	}
	return r.SelectedCard
}

func (r *playerR) GetGithubStar() *GithubStar {
	if r == nil {
		return nil
	}
	return r.GithubStar
}

func (r *playerR) GetAuctions() AuctionSlice {
	if r == nil {
		return nil
	}
	return r.Auctions
}

func (r *playerR) GetAuctionsBids() AuctionsBidSlice {
	if r == nil {
		return nil
	}
	return r.AuctionsBids
}

func (r *playerR) GetAuthCookies() AuthCookieSlice {
	if r == nil {
		return nil
	}
	return r.AuthCookies
}

func (r *playerR) GetAuthDiscordStates() AuthDiscordStateSlice {
	if r == nil {
		return nil
	}
	return r.AuthDiscordStates
}

func (r *playerR) GetAuthGithubStates() AuthGithubStateSlice {
	if r == nil {
		return nil
	}
	return r.AuthGithubStates
}

func (r *playerR) GetCards() CardSlice {
	if r == nil {
		return nil
	}
	return r.Cards
}

func (r *playerR) GetListings() ListingSlice {
	if r == nil {
		return nil
	}
	return r.Listings
}

func (r *playerR) GetLootBoxes() LootBoxSlice {
	if r == nil {
		return nil
	}
	return r.LootBoxes
}

func (r *playerR) GetPlayerCardFavorites() PlayerCardFavoriteSlice {
	if r == nil {
		return nil
	}
	return r.PlayerCardFavorites
}

func (r *playerR) GetPlayerCards() PlayerCardSlice {
	if r == nil {
		return nil
	}
	return r.PlayerCards
}

func (r *playerR) GetPlayerCardsDecks() PlayerCardsDeckSlice {
	if r == nil {
		return nil
	}
	return r.PlayerCardsDecks
}

// playerL is where Load methods for each relationship are stored.
type playerL struct{}

var (
	playerAllColumns            = []string{"id", "created_at", "updated_at", "deleted_at", "selected_card_id", "liens", "level", "xp", "next_level_xp", "backpack_level", "liens_bidded", "username", "slots_reserved"}
	playerColumnsWithoutDefault = []string{"id"}
	playerColumnsWithDefault    = []string{"created_at", "updated_at", "deleted_at", "selected_card_id", "liens", "level", "xp", "next_level_xp", "backpack_level", "liens_bidded", "username", "slots_reserved"}
	playerPrimaryKeyColumns     = []string{"id"}
	playerGeneratedColumns      = []string{}
)

type (
	// PlayerSlice is an alias for a slice of pointers to Player.
	// This should almost always be used instead of []Player.
	PlayerSlice []*Player
	// PlayerHook is the signature for custom Player hook methods
	PlayerHook func(context.Context, boil.ContextExecutor, *Player) error

	playerQuery struct {
		*queries.Query
	}
)

// Cache for insert, update and upsert
var (
	playerType                 = reflect.TypeOf(&Player{})
	playerMapping              = queries.MakeStructMapping(playerType)
	playerPrimaryKeyMapping, _ = queries.BindMapping(playerType, playerMapping, playerPrimaryKeyColumns)
	playerInsertCacheMut       sync.RWMutex
	playerInsertCache          = make(map[string]insertCache)
	playerUpdateCacheMut       sync.RWMutex
	playerUpdateCache          = make(map[string]updateCache)
	playerUpsertCacheMut       sync.RWMutex
	playerUpsertCache          = make(map[string]insertCache)
)

var (
	// Force time package dependency for automated UpdatedAt/CreatedAt.
	_ = time.Second
	// Force qmhelper dependency for where clause generation (which doesn't
	// always happen)
	_ = qmhelper.Where
)

var playerAfterSelectMu sync.Mutex
var playerAfterSelectHooks []PlayerHook

var playerBeforeInsertMu sync.Mutex
var playerBeforeInsertHooks []PlayerHook
var playerAfterInsertMu sync.Mutex
var playerAfterInsertHooks []PlayerHook

var playerBeforeUpdateMu sync.Mutex
var playerBeforeUpdateHooks []PlayerHook
var playerAfterUpdateMu sync.Mutex
var playerAfterUpdateHooks []PlayerHook

var playerBeforeDeleteMu sync.Mutex
var playerBeforeDeleteHooks []PlayerHook
var playerAfterDeleteMu sync.Mutex
var playerAfterDeleteHooks []PlayerHook

var playerBeforeUpsertMu sync.Mutex
var playerBeforeUpsertHooks []PlayerHook
var playerAfterUpsertMu sync.Mutex
var playerAfterUpsertHooks []PlayerHook

// doAfterSelectHooks executes all "after Select" hooks.
func (o *Player) doAfterSelectHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range playerAfterSelectHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeInsertHooks executes all "before insert" hooks.
func (o *Player) doBeforeInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range playerBeforeInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterInsertHooks executes all "after Insert" hooks.
func (o *Player) doAfterInsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range playerAfterInsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpdateHooks executes all "before Update" hooks.
func (o *Player) doBeforeUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range playerBeforeUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpdateHooks executes all "after Update" hooks.
func (o *Player) doAfterUpdateHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range playerAfterUpdateHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeDeleteHooks executes all "before Delete" hooks.
func (o *Player) doBeforeDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range playerBeforeDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterDeleteHooks executes all "after Delete" hooks.
func (o *Player) doAfterDeleteHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range playerAfterDeleteHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doBeforeUpsertHooks executes all "before Upsert" hooks.
func (o *Player) doBeforeUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range playerBeforeUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// doAfterUpsertHooks executes all "after Upsert" hooks.
func (o *Player) doAfterUpsertHooks(ctx context.Context, exec boil.ContextExecutor) (err error) {
	if boil.HooksAreSkipped(ctx) {
		return nil
	}

	for _, hook := range playerAfterUpsertHooks {
		if err := hook(ctx, exec, o); err != nil {
			return err
		}
	}

	return nil
}

// AddPlayerHook registers your hook function for all future operations.
func AddPlayerHook(hookPoint boil.HookPoint, playerHook PlayerHook) {
	switch hookPoint {
	case boil.AfterSelectHook:
		playerAfterSelectMu.Lock()
		playerAfterSelectHooks = append(playerAfterSelectHooks, playerHook)
		playerAfterSelectMu.Unlock()
	case boil.BeforeInsertHook:
		playerBeforeInsertMu.Lock()
		playerBeforeInsertHooks = append(playerBeforeInsertHooks, playerHook)
		playerBeforeInsertMu.Unlock()
	case boil.AfterInsertHook:
		playerAfterInsertMu.Lock()
		playerAfterInsertHooks = append(playerAfterInsertHooks, playerHook)
		playerAfterInsertMu.Unlock()
	case boil.BeforeUpdateHook:
		playerBeforeUpdateMu.Lock()
		playerBeforeUpdateHooks = append(playerBeforeUpdateHooks, playerHook)
		playerBeforeUpdateMu.Unlock()
	case boil.AfterUpdateHook:
		playerAfterUpdateMu.Lock()
		playerAfterUpdateHooks = append(playerAfterUpdateHooks, playerHook)
		playerAfterUpdateMu.Unlock()
	case boil.BeforeDeleteHook:
		playerBeforeDeleteMu.Lock()
		playerBeforeDeleteHooks = append(playerBeforeDeleteHooks, playerHook)
		playerBeforeDeleteMu.Unlock()
	case boil.AfterDeleteHook:
		playerAfterDeleteMu.Lock()
		playerAfterDeleteHooks = append(playerAfterDeleteHooks, playerHook)
		playerAfterDeleteMu.Unlock()
	case boil.BeforeUpsertHook:
		playerBeforeUpsertMu.Lock()
		playerBeforeUpsertHooks = append(playerBeforeUpsertHooks, playerHook)
		playerBeforeUpsertMu.Unlock()
	case boil.AfterUpsertHook:
		playerAfterUpsertMu.Lock()
		playerAfterUpsertHooks = append(playerAfterUpsertHooks, playerHook)
		playerAfterUpsertMu.Unlock()
	}
}

// OneG returns a single player record from the query using the global executor.
func (q playerQuery) OneG(ctx context.Context) (*Player, error) {
	return q.One(ctx, boil.GetContextDB())
}

// One returns a single player record from the query.
func (q playerQuery) One(ctx context.Context, exec boil.ContextExecutor) (*Player, error) {
	o := &Player{}

	queries.SetLimit(q.Query, 1)

	err := q.Bind(ctx, exec, o)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: failed to execute a one query for players")
	}

	if err := o.doAfterSelectHooks(ctx, exec); err != nil {
		return o, err
	}

	return o, nil
}

// AllG returns all Player records from the query using the global executor.
func (q playerQuery) AllG(ctx context.Context) (PlayerSlice, error) {
	return q.All(ctx, boil.GetContextDB())
}

// All returns all Player records from the query.
func (q playerQuery) All(ctx context.Context, exec boil.ContextExecutor) (PlayerSlice, error) {
	var o []*Player

	err := q.Bind(ctx, exec, &o)
	if err != nil {
		return nil, errors.Wrap(err, "models: failed to assign all query results to Player slice")
	}

	if len(playerAfterSelectHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterSelectHooks(ctx, exec); err != nil {
				return o, err
			}
		}
	}

	return o, nil
}

// CountG returns the count of all Player records in the query using the global executor
func (q playerQuery) CountG(ctx context.Context) (int64, error) {
	return q.Count(ctx, boil.GetContextDB())
}

// Count returns the count of all Player records in the query.
func (q playerQuery) Count(ctx context.Context, exec boil.ContextExecutor) (int64, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to count players rows")
	}

	return count, nil
}

// ExistsG checks if the row exists in the table using the global executor.
func (q playerQuery) ExistsG(ctx context.Context) (bool, error) {
	return q.Exists(ctx, boil.GetContextDB())
}

// Exists checks if the row exists in the table.
func (q playerQuery) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	var count int64

	queries.SetSelect(q.Query, nil)
	queries.SetCount(q.Query)
	queries.SetLimit(q.Query, 1)

	err := q.Query.QueryRowContext(ctx, exec).Scan(&count)
	if err != nil {
		return false, errors.Wrap(err, "models: failed to check if players exists")
	}

	return count > 0, nil
}

// IDGithubStar pointed to by the foreign key.
func (o *Player) IDGithubStar(mods ...qm.QueryMod) githubStarQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"player_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	return GithubStars(queryMods...)
}

// SelectedCard pointed to by the foreign key.
func (o *Player) SelectedCard(mods ...qm.QueryMod) cardQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"id\" = ?", o.SelectedCardID),
	}

	queryMods = append(queryMods, mods...)

	return Cards(queryMods...)
}

// GithubStar pointed to by the foreign key.
func (o *Player) GithubStar(mods ...qm.QueryMod) githubStarQuery {
	queryMods := []qm.QueryMod{
		qm.Where("\"player_id\" = ?", o.ID),
	}

	queryMods = append(queryMods, mods...)

	return GithubStars(queryMods...)
}

// Auctions retrieves all the auction's Auctions with an executor.
func (o *Player) Auctions(mods ...qm.QueryMod) auctionQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"auctions\".\"player_id\"=?", o.ID),
	)

	return Auctions(queryMods...)
}

// AuctionsBids retrieves all the auctions_bid's AuctionsBids with an executor.
func (o *Player) AuctionsBids(mods ...qm.QueryMod) auctionsBidQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"auctions_bids\".\"player_id\"=?", o.ID),
	)

	return AuctionsBids(queryMods...)
}

// AuthCookies retrieves all the auth_cookie's AuthCookies with an executor.
func (o *Player) AuthCookies(mods ...qm.QueryMod) authCookieQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"auth_cookies\".\"player_id\"=?", o.ID),
	)

	return AuthCookies(queryMods...)
}

// AuthDiscordStates retrieves all the auth_discord_state's AuthDiscordStates with an executor.
func (o *Player) AuthDiscordStates(mods ...qm.QueryMod) authDiscordStateQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"auth_discord_states\".\"player_id\"=?", o.ID),
	)

	return AuthDiscordStates(queryMods...)
}

// AuthGithubStates retrieves all the auth_github_state's AuthGithubStates with an executor.
func (o *Player) AuthGithubStates(mods ...qm.QueryMod) authGithubStateQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"auth_github_states\".\"player_id\"=?", o.ID),
	)

	return AuthGithubStates(queryMods...)
}

// Cards retrieves all the card's Cards with an executor.
func (o *Player) Cards(mods ...qm.QueryMod) cardQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"cards\".\"player_id\"=?", o.ID),
	)

	return Cards(queryMods...)
}

// Listings retrieves all the listing's Listings with an executor.
func (o *Player) Listings(mods ...qm.QueryMod) listingQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"listings\".\"player_id\"=?", o.ID),
	)

	return Listings(queryMods...)
}

// LootBoxes retrieves all the loot_box's LootBoxes with an executor.
func (o *Player) LootBoxes(mods ...qm.QueryMod) lootBoxQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"loot_boxes\".\"player_id\"=?", o.ID),
	)

	return LootBoxes(queryMods...)
}

// PlayerCardFavorites retrieves all the player_card_favorite's PlayerCardFavorites with an executor.
func (o *Player) PlayerCardFavorites(mods ...qm.QueryMod) playerCardFavoriteQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_card_favorites\".\"player_id\"=?", o.ID),
	)

	return PlayerCardFavorites(queryMods...)
}

// PlayerCards retrieves all the player_card's PlayerCards with an executor.
func (o *Player) PlayerCards(mods ...qm.QueryMod) playerCardQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_cards\".\"player_id\"=?", o.ID),
	)

	return PlayerCards(queryMods...)
}

// PlayerCardsDecks retrieves all the player_cards_deck's PlayerCardsDecks with an executor.
func (o *Player) PlayerCardsDecks(mods ...qm.QueryMod) playerCardsDeckQuery {
	var queryMods []qm.QueryMod
	if len(mods) != 0 {
		queryMods = append(queryMods, mods...)
	}

	queryMods = append(queryMods,
		qm.Where("\"player_cards_deck\".\"player_id\"=?", o.ID),
	)

	return PlayerCardsDecks(queryMods...)
}

// LoadIDGithubStar allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (playerL) LoadIDGithubStar(ctx context.Context, e boil.ContextExecutor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		var ok bool
		object, ok = maybePlayer.(*Player)
		if !ok {
			object = new(Player)
			ok = queries.SetFromEmbeddedStruct(&object, &maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybePlayer))
			}
		}
	} else {
		s, ok := maybePlayer.(*[]*Player)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybePlayer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args[object.ID] = struct{}{}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			args[obj.ID] = struct{}{}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`github_stars`),
		qm.WhereIn(`github_stars.player_id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`github_stars.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load GithubStar")
	}

	var resultSlice []*GithubStar
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice GithubStar")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for github_stars")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for github_stars")
	}

	if len(githubStarAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.IDGithubStar = foreign
		if foreign.R == nil {
			foreign.R = &githubStarR{}
		}
		foreign.R.IDPlayer = object
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ID == foreign.PlayerID {
				local.R.IDGithubStar = foreign
				if foreign.R == nil {
					foreign.R = &githubStarR{}
				}
				foreign.R.IDPlayer = local
				break
			}
		}
	}

	return nil
}

// LoadSelectedCard allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for an N-1 relationship.
func (playerL) LoadSelectedCard(ctx context.Context, e boil.ContextExecutor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		var ok bool
		object, ok = maybePlayer.(*Player)
		if !ok {
			object = new(Player)
			ok = queries.SetFromEmbeddedStruct(&object, &maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybePlayer))
			}
		}
	} else {
		s, ok := maybePlayer.(*[]*Player)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybePlayer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		if !queries.IsNil(object.SelectedCardID) {
			args[object.SelectedCardID] = struct{}{}
		}

	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			if !queries.IsNil(obj.SelectedCardID) {
				args[obj.SelectedCardID] = struct{}{}
			}

		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`cards`),
		qm.WhereIn(`cards.id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`cards.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load Card")
	}

	var resultSlice []*Card
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice Card")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for cards")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for cards")
	}

	if len(cardAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.SelectedCard = foreign
		if foreign.R == nil {
			foreign.R = &cardR{}
		}
		foreign.R.SelectedCardPlayers = append(foreign.R.SelectedCardPlayers, object)
		return nil
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if queries.Equal(local.SelectedCardID, foreign.ID) {
				local.R.SelectedCard = foreign
				if foreign.R == nil {
					foreign.R = &cardR{}
				}
				foreign.R.SelectedCardPlayers = append(foreign.R.SelectedCardPlayers, local)
				break
			}
		}
	}

	return nil
}

// LoadGithubStar allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-1 relationship.
func (playerL) LoadGithubStar(ctx context.Context, e boil.ContextExecutor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		var ok bool
		object, ok = maybePlayer.(*Player)
		if !ok {
			object = new(Player)
			ok = queries.SetFromEmbeddedStruct(&object, &maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybePlayer))
			}
		}
	} else {
		s, ok := maybePlayer.(*[]*Player)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybePlayer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}

			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`github_stars`),
		qm.WhereIn(`github_stars.player_id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`github_stars.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load GithubStar")
	}

	var resultSlice []*GithubStar
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice GithubStar")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results of eager load for github_stars")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for github_stars")
	}

	if len(githubStarAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}

	if len(resultSlice) == 0 {
		return nil
	}

	if singular {
		foreign := resultSlice[0]
		object.R.GithubStar = foreign
		if foreign.R == nil {
			foreign.R = &githubStarR{}
		}
		foreign.R.Player = object
	}

	for _, local := range slice {
		for _, foreign := range resultSlice {
			if local.ID == foreign.PlayerID {
				local.R.GithubStar = foreign
				if foreign.R == nil {
					foreign.R = &githubStarR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadAuctions allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadAuctions(ctx context.Context, e boil.ContextExecutor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		var ok bool
		object, ok = maybePlayer.(*Player)
		if !ok {
			object = new(Player)
			ok = queries.SetFromEmbeddedStruct(&object, &maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybePlayer))
			}
		}
	} else {
		s, ok := maybePlayer.(*[]*Player)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybePlayer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`auctions`),
		qm.WhereIn(`auctions.player_id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`auctions.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load auctions")
	}

	var resultSlice []*Auction
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice auctions")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on auctions")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for auctions")
	}

	if len(auctionAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Auctions = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &auctionR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.Auctions = append(local.R.Auctions, foreign)
				if foreign.R == nil {
					foreign.R = &auctionR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadAuctionsBids allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadAuctionsBids(ctx context.Context, e boil.ContextExecutor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		var ok bool
		object, ok = maybePlayer.(*Player)
		if !ok {
			object = new(Player)
			ok = queries.SetFromEmbeddedStruct(&object, &maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybePlayer))
			}
		}
	} else {
		s, ok := maybePlayer.(*[]*Player)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybePlayer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`auctions_bids`),
		qm.WhereIn(`auctions_bids.player_id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`auctions_bids.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load auctions_bids")
	}

	var resultSlice []*AuctionsBid
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice auctions_bids")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on auctions_bids")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for auctions_bids")
	}

	if len(auctionsBidAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AuctionsBids = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &auctionsBidR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.AuctionsBids = append(local.R.AuctionsBids, foreign)
				if foreign.R == nil {
					foreign.R = &auctionsBidR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadAuthCookies allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadAuthCookies(ctx context.Context, e boil.ContextExecutor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		var ok bool
		object, ok = maybePlayer.(*Player)
		if !ok {
			object = new(Player)
			ok = queries.SetFromEmbeddedStruct(&object, &maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybePlayer))
			}
		}
	} else {
		s, ok := maybePlayer.(*[]*Player)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybePlayer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`auth_cookies`),
		qm.WhereIn(`auth_cookies.player_id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`auth_cookies.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load auth_cookies")
	}

	var resultSlice []*AuthCookie
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice auth_cookies")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on auth_cookies")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for auth_cookies")
	}

	if len(authCookieAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AuthCookies = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &authCookieR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.AuthCookies = append(local.R.AuthCookies, foreign)
				if foreign.R == nil {
					foreign.R = &authCookieR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadAuthDiscordStates allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadAuthDiscordStates(ctx context.Context, e boil.ContextExecutor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		var ok bool
		object, ok = maybePlayer.(*Player)
		if !ok {
			object = new(Player)
			ok = queries.SetFromEmbeddedStruct(&object, &maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybePlayer))
			}
		}
	} else {
		s, ok := maybePlayer.(*[]*Player)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybePlayer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`auth_discord_states`),
		qm.WhereIn(`auth_discord_states.player_id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`auth_discord_states.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load auth_discord_states")
	}

	var resultSlice []*AuthDiscordState
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice auth_discord_states")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on auth_discord_states")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for auth_discord_states")
	}

	if len(authDiscordStateAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AuthDiscordStates = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &authDiscordStateR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if queries.Equal(local.ID, foreign.PlayerID) {
				local.R.AuthDiscordStates = append(local.R.AuthDiscordStates, foreign)
				if foreign.R == nil {
					foreign.R = &authDiscordStateR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadAuthGithubStates allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadAuthGithubStates(ctx context.Context, e boil.ContextExecutor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		var ok bool
		object, ok = maybePlayer.(*Player)
		if !ok {
			object = new(Player)
			ok = queries.SetFromEmbeddedStruct(&object, &maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybePlayer))
			}
		}
	} else {
		s, ok := maybePlayer.(*[]*Player)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybePlayer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`auth_github_states`),
		qm.WhereIn(`auth_github_states.player_id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`auth_github_states.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load auth_github_states")
	}

	var resultSlice []*AuthGithubState
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice auth_github_states")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on auth_github_states")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for auth_github_states")
	}

	if len(authGithubStateAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.AuthGithubStates = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &authGithubStateR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.AuthGithubStates = append(local.R.AuthGithubStates, foreign)
				if foreign.R == nil {
					foreign.R = &authGithubStateR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadCards allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadCards(ctx context.Context, e boil.ContextExecutor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		var ok bool
		object, ok = maybePlayer.(*Player)
		if !ok {
			object = new(Player)
			ok = queries.SetFromEmbeddedStruct(&object, &maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybePlayer))
			}
		}
	} else {
		s, ok := maybePlayer.(*[]*Player)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybePlayer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`cards`),
		qm.WhereIn(`cards.player_id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`cards.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load cards")
	}

	var resultSlice []*Card
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice cards")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on cards")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for cards")
	}

	if len(cardAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Cards = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &cardR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.Cards = append(local.R.Cards, foreign)
				if foreign.R == nil {
					foreign.R = &cardR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadListings allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadListings(ctx context.Context, e boil.ContextExecutor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		var ok bool
		object, ok = maybePlayer.(*Player)
		if !ok {
			object = new(Player)
			ok = queries.SetFromEmbeddedStruct(&object, &maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybePlayer))
			}
		}
	} else {
		s, ok := maybePlayer.(*[]*Player)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybePlayer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`listings`),
		qm.WhereIn(`listings.player_id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`listings.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load listings")
	}

	var resultSlice []*Listing
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice listings")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on listings")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for listings")
	}

	if len(listingAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.Listings = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &listingR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.Listings = append(local.R.Listings, foreign)
				if foreign.R == nil {
					foreign.R = &listingR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadLootBoxes allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadLootBoxes(ctx context.Context, e boil.ContextExecutor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		var ok bool
		object, ok = maybePlayer.(*Player)
		if !ok {
			object = new(Player)
			ok = queries.SetFromEmbeddedStruct(&object, &maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybePlayer))
			}
		}
	} else {
		s, ok := maybePlayer.(*[]*Player)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybePlayer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`loot_boxes`),
		qm.WhereIn(`loot_boxes.player_id in ?`, argsSlice...),
		qmhelper.WhereIsNull(`loot_boxes.deleted_at`),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load loot_boxes")
	}

	var resultSlice []*LootBox
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice loot_boxes")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on loot_boxes")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for loot_boxes")
	}

	if len(lootBoxAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.LootBoxes = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &lootBoxR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.LootBoxes = append(local.R.LootBoxes, foreign)
				if foreign.R == nil {
					foreign.R = &lootBoxR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerCardFavorites allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerCardFavorites(ctx context.Context, e boil.ContextExecutor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		var ok bool
		object, ok = maybePlayer.(*Player)
		if !ok {
			object = new(Player)
			ok = queries.SetFromEmbeddedStruct(&object, &maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybePlayer))
			}
		}
	} else {
		s, ok := maybePlayer.(*[]*Player)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybePlayer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`player_card_favorites`),
		qm.WhereIn(`player_card_favorites.player_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_card_favorites")
	}

	var resultSlice []*PlayerCardFavorite
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_card_favorites")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_card_favorites")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_card_favorites")
	}

	if len(playerCardFavoriteAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerCardFavorites = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerCardFavoriteR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerCardFavorites = append(local.R.PlayerCardFavorites, foreign)
				if foreign.R == nil {
					foreign.R = &playerCardFavoriteR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerCards allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerCards(ctx context.Context, e boil.ContextExecutor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		var ok bool
		object, ok = maybePlayer.(*Player)
		if !ok {
			object = new(Player)
			ok = queries.SetFromEmbeddedStruct(&object, &maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybePlayer))
			}
		}
	} else {
		s, ok := maybePlayer.(*[]*Player)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybePlayer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`player_cards`),
		qm.WhereIn(`player_cards.player_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_cards")
	}

	var resultSlice []*PlayerCard
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_cards")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_cards")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_cards")
	}

	if len(playerCardAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerCards = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerCardR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerCards = append(local.R.PlayerCards, foreign)
				if foreign.R == nil {
					foreign.R = &playerCardR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// LoadPlayerCardsDecks allows an eager lookup of values, cached into the
// loaded structs of the objects. This is for a 1-M or N-M relationship.
func (playerL) LoadPlayerCardsDecks(ctx context.Context, e boil.ContextExecutor, singular bool, maybePlayer interface{}, mods queries.Applicator) error {
	var slice []*Player
	var object *Player

	if singular {
		var ok bool
		object, ok = maybePlayer.(*Player)
		if !ok {
			object = new(Player)
			ok = queries.SetFromEmbeddedStruct(&object, &maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", object, maybePlayer))
			}
		}
	} else {
		s, ok := maybePlayer.(*[]*Player)
		if ok {
			slice = *s
		} else {
			ok = queries.SetFromEmbeddedStruct(&slice, maybePlayer)
			if !ok {
				return errors.New(fmt.Sprintf("failed to set %T from embedded struct %T", slice, maybePlayer))
			}
		}
	}

	args := make(map[interface{}]struct{})
	if singular {
		if object.R == nil {
			object.R = &playerR{}
		}
		args[object.ID] = struct{}{}
	} else {
		for _, obj := range slice {
			if obj.R == nil {
				obj.R = &playerR{}
			}
			args[obj.ID] = struct{}{}
		}
	}

	if len(args) == 0 {
		return nil
	}

	argsSlice := make([]interface{}, len(args))
	i := 0
	for arg := range args {
		argsSlice[i] = arg
		i++
	}

	query := NewQuery(
		qm.From(`player_cards_deck`),
		qm.WhereIn(`player_cards_deck.player_id in ?`, argsSlice...),
	)
	if mods != nil {
		mods.Apply(query)
	}

	results, err := query.QueryContext(ctx, e)
	if err != nil {
		return errors.Wrap(err, "failed to eager load player_cards_deck")
	}

	var resultSlice []*PlayerCardsDeck
	if err = queries.Bind(results, &resultSlice); err != nil {
		return errors.Wrap(err, "failed to bind eager loaded slice player_cards_deck")
	}

	if err = results.Close(); err != nil {
		return errors.Wrap(err, "failed to close results in eager load on player_cards_deck")
	}
	if err = results.Err(); err != nil {
		return errors.Wrap(err, "error occurred during iteration of eager loaded relations for player_cards_deck")
	}

	if len(playerCardsDeckAfterSelectHooks) != 0 {
		for _, obj := range resultSlice {
			if err := obj.doAfterSelectHooks(ctx, e); err != nil {
				return err
			}
		}
	}
	if singular {
		object.R.PlayerCardsDecks = resultSlice
		for _, foreign := range resultSlice {
			if foreign.R == nil {
				foreign.R = &playerCardsDeckR{}
			}
			foreign.R.Player = object
		}
		return nil
	}

	for _, foreign := range resultSlice {
		for _, local := range slice {
			if local.ID == foreign.PlayerID {
				local.R.PlayerCardsDecks = append(local.R.PlayerCardsDecks, foreign)
				if foreign.R == nil {
					foreign.R = &playerCardsDeckR{}
				}
				foreign.R.Player = local
				break
			}
		}
	}

	return nil
}

// SetIDGithubStarG of the player to the related item.
// Sets o.R.IDGithubStar to related.
// Adds o to related.R.IDPlayer.
// Uses the global database handle.
func (o *Player) SetIDGithubStarG(ctx context.Context, insert bool, related *GithubStar) error {
	return o.SetIDGithubStar(ctx, boil.GetContextDB(), insert, related)
}

// SetIDGithubStar of the player to the related item.
// Sets o.R.IDGithubStar to related.
// Adds o to related.R.IDPlayer.
func (o *Player) SetIDGithubStar(ctx context.Context, exec boil.ContextExecutor, insert bool, related *GithubStar) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"players\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"id"}),
		strmangle.WhereClause("\"", "\"", 2, playerPrimaryKeyColumns),
	)
	values := []interface{}{related.PlayerID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	o.ID = related.PlayerID
	if o.R == nil {
		o.R = &playerR{
			IDGithubStar: related,
		}
	} else {
		o.R.IDGithubStar = related
	}

	if related.R == nil {
		related.R = &githubStarR{
			IDPlayer: o,
		}
	} else {
		related.R.IDPlayer = o
	}

	return nil
}

// SetSelectedCardG of the player to the related item.
// Sets o.R.SelectedCard to related.
// Adds o to related.R.SelectedCardPlayers.
// Uses the global database handle.
func (o *Player) SetSelectedCardG(ctx context.Context, insert bool, related *Card) error {
	return o.SetSelectedCard(ctx, boil.GetContextDB(), insert, related)
}

// SetSelectedCard of the player to the related item.
// Sets o.R.SelectedCard to related.
// Adds o to related.R.SelectedCardPlayers.
func (o *Player) SetSelectedCard(ctx context.Context, exec boil.ContextExecutor, insert bool, related *Card) error {
	var err error
	if insert {
		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	}

	updateQuery := fmt.Sprintf(
		"UPDATE \"players\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, []string{"selected_card_id"}),
		strmangle.WhereClause("\"", "\"", 2, playerPrimaryKeyColumns),
	)
	values := []interface{}{related.ID, o.ID}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, updateQuery)
		fmt.Fprintln(writer, values)
	}
	if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	queries.Assign(&o.SelectedCardID, related.ID)
	if o.R == nil {
		o.R = &playerR{
			SelectedCard: related,
		}
	} else {
		o.R.SelectedCard = related
	}

	if related.R == nil {
		related.R = &cardR{
			SelectedCardPlayers: PlayerSlice{o},
		}
	} else {
		related.R.SelectedCardPlayers = append(related.R.SelectedCardPlayers, o)
	}

	return nil
}

// RemoveSelectedCardG relationship.
// Sets o.R.SelectedCard to nil.
// Removes o from all passed in related items' relationships struct.
// Uses the global database handle.
func (o *Player) RemoveSelectedCardG(ctx context.Context, related *Card) error {
	return o.RemoveSelectedCard(ctx, boil.GetContextDB(), related)
}

// RemoveSelectedCard relationship.
// Sets o.R.SelectedCard to nil.
// Removes o from all passed in related items' relationships struct.
func (o *Player) RemoveSelectedCard(ctx context.Context, exec boil.ContextExecutor, related *Card) error {
	var err error

	queries.SetScanner(&o.SelectedCardID, nil)
	if _, err = o.Update(ctx, exec, boil.Whitelist("selected_card_id")); err != nil {
		return errors.Wrap(err, "failed to update local table")
	}

	if o.R != nil {
		o.R.SelectedCard = nil
	}
	if related == nil || related.R == nil {
		return nil
	}

	for i, ri := range related.R.SelectedCardPlayers {
		if queries.Equal(o.SelectedCardID, ri.SelectedCardID) {
			continue
		}

		ln := len(related.R.SelectedCardPlayers)
		if ln > 1 && i < ln-1 {
			related.R.SelectedCardPlayers[i] = related.R.SelectedCardPlayers[ln-1]
		}
		related.R.SelectedCardPlayers = related.R.SelectedCardPlayers[:ln-1]
		break
	}
	return nil
}

// SetGithubStarG of the player to the related item.
// Sets o.R.GithubStar to related.
// Adds o to related.R.Player.
// Uses the global database handle.
func (o *Player) SetGithubStarG(ctx context.Context, insert bool, related *GithubStar) error {
	return o.SetGithubStar(ctx, boil.GetContextDB(), insert, related)
}

// SetGithubStar of the player to the related item.
// Sets o.R.GithubStar to related.
// Adds o to related.R.Player.
func (o *Player) SetGithubStar(ctx context.Context, exec boil.ContextExecutor, insert bool, related *GithubStar) error {
	var err error

	if insert {
		related.PlayerID = o.ID

		if err = related.Insert(ctx, exec, boil.Infer()); err != nil {
			return errors.Wrap(err, "failed to insert into foreign table")
		}
	} else {
		updateQuery := fmt.Sprintf(
			"UPDATE \"github_stars\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
			strmangle.WhereClause("\"", "\"", 2, githubStarPrimaryKeyColumns),
		)
		values := []interface{}{o.ID, related.PlayerID}

		if boil.IsDebug(ctx) {
			writer := boil.DebugWriterFrom(ctx)
			fmt.Fprintln(writer, updateQuery)
			fmt.Fprintln(writer, values)
		}
		if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
			return errors.Wrap(err, "failed to update foreign table")
		}

		related.PlayerID = o.ID
	}

	if o.R == nil {
		o.R = &playerR{
			GithubStar: related,
		}
	} else {
		o.R.GithubStar = related
	}

	if related.R == nil {
		related.R = &githubStarR{
			Player: o,
		}
	} else {
		related.R.Player = o
	}
	return nil
}

// AddAuctionsG adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.Auctions.
// Sets related.R.Player appropriately.
// Uses the global database handle.
func (o *Player) AddAuctionsG(ctx context.Context, insert bool, related ...*Auction) error {
	return o.AddAuctions(ctx, boil.GetContextDB(), insert, related...)
}

// AddAuctions adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.Auctions.
// Sets related.R.Player appropriately.
func (o *Player) AddAuctions(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Auction) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"auctions\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, auctionPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			Auctions: related,
		}
	} else {
		o.R.Auctions = append(o.R.Auctions, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &auctionR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddAuctionsBidsG adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.AuctionsBids.
// Sets related.R.Player appropriately.
// Uses the global database handle.
func (o *Player) AddAuctionsBidsG(ctx context.Context, insert bool, related ...*AuctionsBid) error {
	return o.AddAuctionsBids(ctx, boil.GetContextDB(), insert, related...)
}

// AddAuctionsBids adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.AuctionsBids.
// Sets related.R.Player appropriately.
func (o *Player) AddAuctionsBids(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AuctionsBid) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"auctions_bids\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, auctionsBidPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			AuctionsBids: related,
		}
	} else {
		o.R.AuctionsBids = append(o.R.AuctionsBids, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &auctionsBidR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddAuthCookiesG adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.AuthCookies.
// Sets related.R.Player appropriately.
// Uses the global database handle.
func (o *Player) AddAuthCookiesG(ctx context.Context, insert bool, related ...*AuthCookie) error {
	return o.AddAuthCookies(ctx, boil.GetContextDB(), insert, related...)
}

// AddAuthCookies adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.AuthCookies.
// Sets related.R.Player appropriately.
func (o *Player) AddAuthCookies(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AuthCookie) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"auth_cookies\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, authCookiePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			AuthCookies: related,
		}
	} else {
		o.R.AuthCookies = append(o.R.AuthCookies, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &authCookieR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddAuthDiscordStatesG adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.AuthDiscordStates.
// Sets related.R.Player appropriately.
// Uses the global database handle.
func (o *Player) AddAuthDiscordStatesG(ctx context.Context, insert bool, related ...*AuthDiscordState) error {
	return o.AddAuthDiscordStates(ctx, boil.GetContextDB(), insert, related...)
}

// AddAuthDiscordStates adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.AuthDiscordStates.
// Sets related.R.Player appropriately.
func (o *Player) AddAuthDiscordStates(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AuthDiscordState) error {
	var err error
	for _, rel := range related {
		if insert {
			queries.Assign(&rel.PlayerID, o.ID)
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"auth_discord_states\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, authDiscordStatePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.State}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			queries.Assign(&rel.PlayerID, o.ID)
		}
	}

	if o.R == nil {
		o.R = &playerR{
			AuthDiscordStates: related,
		}
	} else {
		o.R.AuthDiscordStates = append(o.R.AuthDiscordStates, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &authDiscordStateR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// SetAuthDiscordStatesG removes all previously related items of the
// player replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Player's AuthDiscordStates accordingly.
// Replaces o.R.AuthDiscordStates with related.
// Sets related.R.Player's AuthDiscordStates accordingly.
// Uses the global database handle.
func (o *Player) SetAuthDiscordStatesG(ctx context.Context, insert bool, related ...*AuthDiscordState) error {
	return o.SetAuthDiscordStates(ctx, boil.GetContextDB(), insert, related...)
}

// SetAuthDiscordStates removes all previously related items of the
// player replacing them completely with the passed
// in related items, optionally inserting them as new records.
// Sets o.R.Player's AuthDiscordStates accordingly.
// Replaces o.R.AuthDiscordStates with related.
// Sets related.R.Player's AuthDiscordStates accordingly.
func (o *Player) SetAuthDiscordStates(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AuthDiscordState) error {
	query := "update \"auth_discord_states\" set \"player_id\" = null where \"player_id\" = $1"
	values := []interface{}{o.ID}
	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, query)
		fmt.Fprintln(writer, values)
	}
	_, err := exec.ExecContext(ctx, query, values...)
	if err != nil {
		return errors.Wrap(err, "failed to remove relationships before set")
	}

	if o.R != nil {
		for _, rel := range o.R.AuthDiscordStates {
			queries.SetScanner(&rel.PlayerID, nil)
			if rel.R == nil {
				continue
			}

			rel.R.Player = nil
		}
		o.R.AuthDiscordStates = nil
	}

	return o.AddAuthDiscordStates(ctx, exec, insert, related...)
}

// RemoveAuthDiscordStatesG relationships from objects passed in.
// Removes related items from R.AuthDiscordStates (uses pointer comparison, removal does not keep order)
// Sets related.R.Player.
// Uses the global database handle.
func (o *Player) RemoveAuthDiscordStatesG(ctx context.Context, related ...*AuthDiscordState) error {
	return o.RemoveAuthDiscordStates(ctx, boil.GetContextDB(), related...)
}

// RemoveAuthDiscordStates relationships from objects passed in.
// Removes related items from R.AuthDiscordStates (uses pointer comparison, removal does not keep order)
// Sets related.R.Player.
func (o *Player) RemoveAuthDiscordStates(ctx context.Context, exec boil.ContextExecutor, related ...*AuthDiscordState) error {
	if len(related) == 0 {
		return nil
	}

	var err error
	for _, rel := range related {
		queries.SetScanner(&rel.PlayerID, nil)
		if rel.R != nil {
			rel.R.Player = nil
		}
		if _, err = rel.Update(ctx, exec, boil.Whitelist("player_id")); err != nil {
			return err
		}
	}
	if o.R == nil {
		return nil
	}

	for _, rel := range related {
		for i, ri := range o.R.AuthDiscordStates {
			if rel != ri {
				continue
			}

			ln := len(o.R.AuthDiscordStates)
			if ln > 1 && i < ln-1 {
				o.R.AuthDiscordStates[i] = o.R.AuthDiscordStates[ln-1]
			}
			o.R.AuthDiscordStates = o.R.AuthDiscordStates[:ln-1]
			break
		}
	}

	return nil
}

// AddAuthGithubStatesG adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.AuthGithubStates.
// Sets related.R.Player appropriately.
// Uses the global database handle.
func (o *Player) AddAuthGithubStatesG(ctx context.Context, insert bool, related ...*AuthGithubState) error {
	return o.AddAuthGithubStates(ctx, boil.GetContextDB(), insert, related...)
}

// AddAuthGithubStates adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.AuthGithubStates.
// Sets related.R.Player appropriately.
func (o *Player) AddAuthGithubStates(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*AuthGithubState) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"auth_github_states\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, authGithubStatePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.State}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			AuthGithubStates: related,
		}
	} else {
		o.R.AuthGithubStates = append(o.R.AuthGithubStates, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &authGithubStateR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddCardsG adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.Cards.
// Sets related.R.Player appropriately.
// Uses the global database handle.
func (o *Player) AddCardsG(ctx context.Context, insert bool, related ...*Card) error {
	return o.AddCards(ctx, boil.GetContextDB(), insert, related...)
}

// AddCards adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.Cards.
// Sets related.R.Player appropriately.
func (o *Player) AddCards(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Card) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"cards\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, cardPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			Cards: related,
		}
	} else {
		o.R.Cards = append(o.R.Cards, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &cardR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddListingsG adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.Listings.
// Sets related.R.Player appropriately.
// Uses the global database handle.
func (o *Player) AddListingsG(ctx context.Context, insert bool, related ...*Listing) error {
	return o.AddListings(ctx, boil.GetContextDB(), insert, related...)
}

// AddListings adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.Listings.
// Sets related.R.Player appropriately.
func (o *Player) AddListings(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*Listing) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"listings\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, listingPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			Listings: related,
		}
	} else {
		o.R.Listings = append(o.R.Listings, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &listingR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddLootBoxesG adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.LootBoxes.
// Sets related.R.Player appropriately.
// Uses the global database handle.
func (o *Player) AddLootBoxesG(ctx context.Context, insert bool, related ...*LootBox) error {
	return o.AddLootBoxes(ctx, boil.GetContextDB(), insert, related...)
}

// AddLootBoxes adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.LootBoxes.
// Sets related.R.Player appropriately.
func (o *Player) AddLootBoxes(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*LootBox) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"loot_boxes\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, lootBoxPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.ID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			LootBoxes: related,
		}
	} else {
		o.R.LootBoxes = append(o.R.LootBoxes, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &lootBoxR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayerCardFavoritesG adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerCardFavorites.
// Sets related.R.Player appropriately.
// Uses the global database handle.
func (o *Player) AddPlayerCardFavoritesG(ctx context.Context, insert bool, related ...*PlayerCardFavorite) error {
	return o.AddPlayerCardFavorites(ctx, boil.GetContextDB(), insert, related...)
}

// AddPlayerCardFavorites adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerCardFavorites.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerCardFavorites(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PlayerCardFavorite) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_card_favorites\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerCardFavoritePrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.PlayerID, rel.CardID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerCardFavorites: related,
		}
	} else {
		o.R.PlayerCardFavorites = append(o.R.PlayerCardFavorites, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerCardFavoriteR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayerCardsG adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerCards.
// Sets related.R.Player appropriately.
// Uses the global database handle.
func (o *Player) AddPlayerCardsG(ctx context.Context, insert bool, related ...*PlayerCard) error {
	return o.AddPlayerCards(ctx, boil.GetContextDB(), insert, related...)
}

// AddPlayerCards adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerCards.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerCards(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PlayerCard) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_cards\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerCardPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.PlayerID, rel.CardID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerCards: related,
		}
	} else {
		o.R.PlayerCards = append(o.R.PlayerCards, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerCardR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// AddPlayerCardsDecksG adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerCardsDecks.
// Sets related.R.Player appropriately.
// Uses the global database handle.
func (o *Player) AddPlayerCardsDecksG(ctx context.Context, insert bool, related ...*PlayerCardsDeck) error {
	return o.AddPlayerCardsDecks(ctx, boil.GetContextDB(), insert, related...)
}

// AddPlayerCardsDecks adds the given related objects to the existing relationships
// of the player, optionally inserting them as new records.
// Appends related to o.R.PlayerCardsDecks.
// Sets related.R.Player appropriately.
func (o *Player) AddPlayerCardsDecks(ctx context.Context, exec boil.ContextExecutor, insert bool, related ...*PlayerCardsDeck) error {
	var err error
	for _, rel := range related {
		if insert {
			rel.PlayerID = o.ID
			if err = rel.Insert(ctx, exec, boil.Infer()); err != nil {
				return errors.Wrap(err, "failed to insert into foreign table")
			}
		} else {
			updateQuery := fmt.Sprintf(
				"UPDATE \"player_cards_deck\" SET %s WHERE %s",
				strmangle.SetParamNames("\"", "\"", 1, []string{"player_id"}),
				strmangle.WhereClause("\"", "\"", 2, playerCardsDeckPrimaryKeyColumns),
			)
			values := []interface{}{o.ID, rel.PlayerID, rel.CardID}

			if boil.IsDebug(ctx) {
				writer := boil.DebugWriterFrom(ctx)
				fmt.Fprintln(writer, updateQuery)
				fmt.Fprintln(writer, values)
			}
			if _, err = exec.ExecContext(ctx, updateQuery, values...); err != nil {
				return errors.Wrap(err, "failed to update foreign table")
			}

			rel.PlayerID = o.ID
		}
	}

	if o.R == nil {
		o.R = &playerR{
			PlayerCardsDecks: related,
		}
	} else {
		o.R.PlayerCardsDecks = append(o.R.PlayerCardsDecks, related...)
	}

	for _, rel := range related {
		if rel.R == nil {
			rel.R = &playerCardsDeckR{
				Player: o,
			}
		} else {
			rel.R.Player = o
		}
	}
	return nil
}

// Players retrieves all the records using an executor.
func Players(mods ...qm.QueryMod) playerQuery {
	mods = append(mods, qm.From("\"players\""), qmhelper.WhereIsNull("\"players\".\"deleted_at\""))
	q := NewQuery(mods...)
	if len(queries.GetSelect(q)) == 0 {
		queries.SetSelect(q, []string{"\"players\".*"})
	}

	return playerQuery{q}
}

// FindPlayerG retrieves a single record by ID.
func FindPlayerG(ctx context.Context, iD string, selectCols ...string) (*Player, error) {
	return FindPlayer(ctx, boil.GetContextDB(), iD, selectCols...)
}

// FindPlayer retrieves a single record by ID with an executor.
// If selectCols is empty Find will return all columns.
func FindPlayer(ctx context.Context, exec boil.ContextExecutor, iD string, selectCols ...string) (*Player, error) {
	playerObj := &Player{}

	sel := "*"
	if len(selectCols) > 0 {
		sel = strings.Join(strmangle.IdentQuoteSlice(dialect.LQ, dialect.RQ, selectCols), ",")
	}
	query := fmt.Sprintf(
		"select %s from \"players\" where \"id\"=$1 and \"deleted_at\" is null", sel,
	)

	q := queries.Raw(query, iD)

	err := q.Bind(ctx, exec, playerObj)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, sql.ErrNoRows
		}
		return nil, errors.Wrap(err, "models: unable to select from players")
	}

	if err = playerObj.doAfterSelectHooks(ctx, exec); err != nil {
		return playerObj, err
	}

	return playerObj, nil
}

// InsertG a single record. See Insert for whitelist behavior description.
func (o *Player) InsertG(ctx context.Context, columns boil.Columns) error {
	return o.Insert(ctx, boil.GetContextDB(), columns)
}

// Insert a single record using an executor.
// See boil.Columns.InsertColumnSet documentation to understand column list inference for inserts.
func (o *Player) Insert(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) error {
	if o == nil {
		return errors.New("models: no players provided for insertion")
	}

	var err error
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		if o.UpdatedAt.IsZero() {
			o.UpdatedAt = currTime
		}
	}

	if err := o.doBeforeInsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(playerColumnsWithDefault, o)

	key := makeCacheKey(columns, nzDefaults)
	playerInsertCacheMut.RLock()
	cache, cached := playerInsertCache[key]
	playerInsertCacheMut.RUnlock()

	if !cached {
		wl, returnColumns := columns.InsertColumnSet(
			playerAllColumns,
			playerColumnsWithDefault,
			playerColumnsWithoutDefault,
			nzDefaults,
		)

		cache.valueMapping, err = queries.BindMapping(playerType, playerMapping, wl)
		if err != nil {
			return err
		}
		cache.retMapping, err = queries.BindMapping(playerType, playerMapping, returnColumns)
		if err != nil {
			return err
		}
		if len(wl) != 0 {
			cache.query = fmt.Sprintf("INSERT INTO \"players\" (\"%s\") %%sVALUES (%s)%%s", strings.Join(wl, "\",\""), strmangle.Placeholders(dialect.UseIndexPlaceholders, len(wl), 1, 1))
		} else {
			cache.query = "INSERT INTO \"players\" %sDEFAULT VALUES%s"
		}

		var queryOutput, queryReturning string

		if len(cache.retMapping) != 0 {
			queryReturning = fmt.Sprintf(" RETURNING \"%s\"", strings.Join(returnColumns, "\",\""))
		}

		cache.query = fmt.Sprintf(cache.query, queryOutput, queryReturning)
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}

	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(queries.PtrsFromMapping(value, cache.retMapping)...)
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}

	if err != nil {
		return errors.Wrap(err, "models: unable to insert into players")
	}

	if !cached {
		playerInsertCacheMut.Lock()
		playerInsertCache[key] = cache
		playerInsertCacheMut.Unlock()
	}

	return o.doAfterInsertHooks(ctx, exec)
}

// UpdateG a single Player record using the global executor.
// See Update for more documentation.
func (o *Player) UpdateG(ctx context.Context, columns boil.Columns) (int64, error) {
	return o.Update(ctx, boil.GetContextDB(), columns)
}

// Update uses an executor to update the Player.
// See boil.Columns.UpdateColumnSet documentation to understand column list inference for updates.
// Update does not automatically update the record in case of default values. Use .Reload() to refresh the records.
func (o *Player) Update(ctx context.Context, exec boil.ContextExecutor, columns boil.Columns) (int64, error) {
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		o.UpdatedAt = currTime
	}

	var err error
	if err = o.doBeforeUpdateHooks(ctx, exec); err != nil {
		return 0, err
	}
	key := makeCacheKey(columns, nil)
	playerUpdateCacheMut.RLock()
	cache, cached := playerUpdateCache[key]
	playerUpdateCacheMut.RUnlock()

	if !cached {
		wl := columns.UpdateColumnSet(
			playerAllColumns,
			playerPrimaryKeyColumns,
		)

		if !columns.IsWhitelist() {
			wl = strmangle.SetComplement(wl, []string{"created_at"})
		}
		if len(wl) == 0 {
			return 0, errors.New("models: unable to update players, could not build whitelist")
		}

		cache.query = fmt.Sprintf("UPDATE \"players\" SET %s WHERE %s",
			strmangle.SetParamNames("\"", "\"", 1, wl),
			strmangle.WhereClause("\"", "\"", len(wl)+1, playerPrimaryKeyColumns),
		)
		cache.valueMapping, err = queries.BindMapping(playerType, playerMapping, append(wl, playerPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
	}

	values := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), cache.valueMapping)

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, values)
	}
	var result sql.Result
	result, err = exec.ExecContext(ctx, cache.query, values...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update players row")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by update for players")
	}

	if !cached {
		playerUpdateCacheMut.Lock()
		playerUpdateCache[key] = cache
		playerUpdateCacheMut.Unlock()
	}

	return rowsAff, o.doAfterUpdateHooks(ctx, exec)
}

// UpdateAllG updates all rows with the specified column values.
func (q playerQuery) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return q.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values.
func (q playerQuery) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	queries.SetUpdate(q.Query, cols)

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all for players")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected for players")
	}

	return rowsAff, nil
}

// UpdateAllG updates all rows with the specified column values.
func (o PlayerSlice) UpdateAllG(ctx context.Context, cols M) (int64, error) {
	return o.UpdateAll(ctx, boil.GetContextDB(), cols)
}

// UpdateAll updates all rows with the specified column values, using an executor.
func (o PlayerSlice) UpdateAll(ctx context.Context, exec boil.ContextExecutor, cols M) (int64, error) {
	ln := int64(len(o))
	if ln == 0 {
		return 0, nil
	}

	if len(cols) == 0 {
		return 0, errors.New("models: update all requires at least one column argument")
	}

	colNames := make([]string, len(cols))
	args := make([]interface{}, len(cols))

	i := 0
	for name, value := range cols {
		colNames[i] = name
		args[i] = value
		i++
	}

	// Append all of the primary key values for each column
	for _, obj := range o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := fmt.Sprintf("UPDATE \"players\" SET %s WHERE %s",
		strmangle.SetParamNames("\"", "\"", 1, colNames),
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), len(colNames)+1, playerPrimaryKeyColumns, len(o)))

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to update all in player slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to retrieve rows affected all in update all player")
	}
	return rowsAff, nil
}

// UpsertG attempts an insert, and does an update or ignore on conflict.
func (o *Player) UpsertG(ctx context.Context, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	return o.Upsert(ctx, boil.GetContextDB(), updateOnConflict, conflictColumns, updateColumns, insertColumns, opts...)
}

// Upsert attempts an insert using an executor, and does an update or ignore on conflict.
// See boil.Columns documentation for how to properly use updateColumns and insertColumns.
func (o *Player) Upsert(ctx context.Context, exec boil.ContextExecutor, updateOnConflict bool, conflictColumns []string, updateColumns, insertColumns boil.Columns, opts ...UpsertOptionFunc) error {
	if o == nil {
		return errors.New("models: no players provided for upsert")
	}
	if !boil.TimestampsAreSkipped(ctx) {
		currTime := time.Now().In(boil.GetLocation())

		if o.CreatedAt.IsZero() {
			o.CreatedAt = currTime
		}
		o.UpdatedAt = currTime
	}

	if err := o.doBeforeUpsertHooks(ctx, exec); err != nil {
		return err
	}

	nzDefaults := queries.NonZeroDefaultSet(playerColumnsWithDefault, o)

	// Build cache key in-line uglily - mysql vs psql problems
	buf := strmangle.GetBuffer()
	if updateOnConflict {
		buf.WriteByte('t')
	} else {
		buf.WriteByte('f')
	}
	buf.WriteByte('.')
	for _, c := range conflictColumns {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(updateColumns.Kind))
	for _, c := range updateColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	buf.WriteString(strconv.Itoa(insertColumns.Kind))
	for _, c := range insertColumns.Cols {
		buf.WriteString(c)
	}
	buf.WriteByte('.')
	for _, c := range nzDefaults {
		buf.WriteString(c)
	}
	key := buf.String()
	strmangle.PutBuffer(buf)

	playerUpsertCacheMut.RLock()
	cache, cached := playerUpsertCache[key]
	playerUpsertCacheMut.RUnlock()

	var err error

	if !cached {
		insert, _ := insertColumns.InsertColumnSet(
			playerAllColumns,
			playerColumnsWithDefault,
			playerColumnsWithoutDefault,
			nzDefaults,
		)

		update := updateColumns.UpdateColumnSet(
			playerAllColumns,
			playerPrimaryKeyColumns,
		)

		if updateOnConflict && len(update) == 0 {
			return errors.New("models: unable to upsert players, could not build update column list")
		}

		ret := strmangle.SetComplement(playerAllColumns, strmangle.SetIntersect(insert, update))

		conflict := conflictColumns
		if len(conflict) == 0 && updateOnConflict && len(update) != 0 {
			if len(playerPrimaryKeyColumns) == 0 {
				return errors.New("models: unable to upsert players, could not build conflict column list")
			}

			conflict = make([]string, len(playerPrimaryKeyColumns))
			copy(conflict, playerPrimaryKeyColumns)
		}
		cache.query = buildUpsertQueryPostgres(dialect, "\"players\"", updateOnConflict, ret, update, conflict, insert, opts...)

		cache.valueMapping, err = queries.BindMapping(playerType, playerMapping, insert)
		if err != nil {
			return err
		}
		if len(ret) != 0 {
			cache.retMapping, err = queries.BindMapping(playerType, playerMapping, ret)
			if err != nil {
				return err
			}
		}
	}

	value := reflect.Indirect(reflect.ValueOf(o))
	vals := queries.ValuesFromMapping(value, cache.valueMapping)
	var returns []interface{}
	if len(cache.retMapping) != 0 {
		returns = queries.PtrsFromMapping(value, cache.retMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, cache.query)
		fmt.Fprintln(writer, vals)
	}
	if len(cache.retMapping) != 0 {
		err = exec.QueryRowContext(ctx, cache.query, vals...).Scan(returns...)
		if errors.Is(err, sql.ErrNoRows) {
			err = nil // Postgres doesn't return anything when there's no update
		}
	} else {
		_, err = exec.ExecContext(ctx, cache.query, vals...)
	}
	if err != nil {
		return errors.Wrap(err, "models: unable to upsert players")
	}

	if !cached {
		playerUpsertCacheMut.Lock()
		playerUpsertCache[key] = cache
		playerUpsertCacheMut.Unlock()
	}

	return o.doAfterUpsertHooks(ctx, exec)
}

// DeleteG deletes a single Player record.
// DeleteG will match against the primary key column to find the record to delete.
func (o *Player) DeleteG(ctx context.Context, hardDelete bool) (int64, error) {
	return o.Delete(ctx, boil.GetContextDB(), hardDelete)
}

// Delete deletes a single Player record with an executor.
// Delete will match against the primary key column to find the record to delete.
func (o *Player) Delete(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if o == nil {
		return 0, errors.New("models: no Player provided for delete")
	}

	if err := o.doBeforeDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), playerPrimaryKeyMapping)
		sql = "DELETE FROM \"players\" WHERE \"id\"=$1"
	} else {
		currTime := time.Now().In(boil.GetLocation())
		o.DeletedAt = null.TimeFrom(currTime)
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"players\" SET %s WHERE \"id\"=$2",
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		valueMapping, err := queries.BindMapping(playerType, playerMapping, append(wl, playerPrimaryKeyColumns...))
		if err != nil {
			return 0, err
		}
		args = queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(o)), valueMapping)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args...)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete from players")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by delete for players")
	}

	if err := o.doAfterDeleteHooks(ctx, exec); err != nil {
		return 0, err
	}

	return rowsAff, nil
}

func (q playerQuery) DeleteAllG(ctx context.Context, hardDelete bool) (int64, error) {
	return q.DeleteAll(ctx, boil.GetContextDB(), hardDelete)
}

// DeleteAll deletes all matching rows.
func (q playerQuery) DeleteAll(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if q.Query == nil {
		return 0, errors.New("models: no playerQuery provided for delete all")
	}

	if hardDelete {
		queries.SetDelete(q.Query)
	} else {
		currTime := time.Now().In(boil.GetLocation())
		queries.SetUpdate(q.Query, M{"deleted_at": currTime})
	}

	result, err := q.Query.ExecContext(ctx, exec)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from players")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for players")
	}

	return rowsAff, nil
}

// DeleteAllG deletes all rows in the slice.
func (o PlayerSlice) DeleteAllG(ctx context.Context, hardDelete bool) (int64, error) {
	return o.DeleteAll(ctx, boil.GetContextDB(), hardDelete)
}

// DeleteAll deletes all rows in the slice, using an executor.
func (o PlayerSlice) DeleteAll(ctx context.Context, exec boil.ContextExecutor, hardDelete bool) (int64, error) {
	if len(o) == 0 {
		return 0, nil
	}

	if len(playerBeforeDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doBeforeDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	var (
		sql  string
		args []interface{}
	)
	if hardDelete {
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
		}
		sql = "DELETE FROM \"players\" WHERE " +
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, playerPrimaryKeyColumns, len(o))
	} else {
		currTime := time.Now().In(boil.GetLocation())
		for _, obj := range o {
			pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerPrimaryKeyMapping)
			args = append(args, pkeyArgs...)
			obj.DeletedAt = null.TimeFrom(currTime)
		}
		wl := []string{"deleted_at"}
		sql = fmt.Sprintf("UPDATE \"players\" SET %s WHERE "+
			strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 2, playerPrimaryKeyColumns, len(o)),
			strmangle.SetParamNames("\"", "\"", 1, wl),
		)
		args = append([]interface{}{currTime}, args...)
	}

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, args)
	}
	result, err := exec.ExecContext(ctx, sql, args...)
	if err != nil {
		return 0, errors.Wrap(err, "models: unable to delete all from player slice")
	}

	rowsAff, err := result.RowsAffected()
	if err != nil {
		return 0, errors.Wrap(err, "models: failed to get rows affected by deleteall for players")
	}

	if len(playerAfterDeleteHooks) != 0 {
		for _, obj := range o {
			if err := obj.doAfterDeleteHooks(ctx, exec); err != nil {
				return 0, err
			}
		}
	}

	return rowsAff, nil
}

// ReloadG refetches the object from the database using the primary keys.
func (o *Player) ReloadG(ctx context.Context) error {
	if o == nil {
		return errors.New("models: no Player provided for reload")
	}

	return o.Reload(ctx, boil.GetContextDB())
}

// Reload refetches the object from the database
// using the primary keys with an executor.
func (o *Player) Reload(ctx context.Context, exec boil.ContextExecutor) error {
	ret, err := FindPlayer(ctx, exec, o.ID)
	if err != nil {
		return err
	}

	*o = *ret
	return nil
}

// ReloadAllG refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *PlayerSlice) ReloadAllG(ctx context.Context) error {
	if o == nil {
		return errors.New("models: empty PlayerSlice provided for reload all")
	}

	return o.ReloadAll(ctx, boil.GetContextDB())
}

// ReloadAll refetches every row with matching primary key column values
// and overwrites the original object slice with the newly updated slice.
func (o *PlayerSlice) ReloadAll(ctx context.Context, exec boil.ContextExecutor) error {
	if o == nil || len(*o) == 0 {
		return nil
	}

	slice := PlayerSlice{}
	var args []interface{}
	for _, obj := range *o {
		pkeyArgs := queries.ValuesFromMapping(reflect.Indirect(reflect.ValueOf(obj)), playerPrimaryKeyMapping)
		args = append(args, pkeyArgs...)
	}

	sql := "SELECT \"players\".* FROM \"players\" WHERE " +
		strmangle.WhereClauseRepeated(string(dialect.LQ), string(dialect.RQ), 1, playerPrimaryKeyColumns, len(*o)) +
		"and \"deleted_at\" is null"

	q := queries.Raw(sql, args...)

	err := q.Bind(ctx, exec, &slice)
	if err != nil {
		return errors.Wrap(err, "models: unable to reload all in PlayerSlice")
	}

	*o = slice

	return nil
}

// PlayerExistsG checks if the Player row exists.
func PlayerExistsG(ctx context.Context, iD string) (bool, error) {
	return PlayerExists(ctx, boil.GetContextDB(), iD)
}

// PlayerExists checks if the Player row exists.
func PlayerExists(ctx context.Context, exec boil.ContextExecutor, iD string) (bool, error) {
	var exists bool
	sql := "select exists(select 1 from \"players\" where \"id\"=$1 and \"deleted_at\" is null limit 1)"

	if boil.IsDebug(ctx) {
		writer := boil.DebugWriterFrom(ctx)
		fmt.Fprintln(writer, sql)
		fmt.Fprintln(writer, iD)
	}
	row := exec.QueryRowContext(ctx, sql, iD)

	err := row.Scan(&exists)
	if err != nil {
		return false, errors.Wrap(err, "models: unable to check if players exists")
	}

	return exists, nil
}

// Exists checks if the Player row exists.
func (o *Player) Exists(ctx context.Context, exec boil.ContextExecutor) (bool, error) {
	return PlayerExists(ctx, exec, o.ID)
}
